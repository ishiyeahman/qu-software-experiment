                         4 .list
                         5 		***************************************************************
                         6 		**各種レジスタ定義
                         7 		***************************************************************
                         8 
                         9 		***************
                        10 		** レジスタ群の先頭
                        11 		***************
                        12 		.equ REGBASE,   0xFFF000          | DMAPを使用．
                        13 		.equ IOBASE,    0x00d00000
                        14 
                        15 		***************
                        16 		** 割り込み関係のレジスタ
                        17 		***************
                        18 		.equ IVR,       REGBASE+0x300     |割り込みベクタレジスタ
                        19 		.equ IMR,       REGBASE+0x304     |割り込みマスクレジスタ
                        20 		.equ ISR,       REGBASE+0x30c     |割り込みステータスレジスタ
                        21 		.equ IPR,       REGBASE+0x310     |割り込みペンディングレジスタ
                        22 
                        23 		***************
                        24 		** タイマ関係のレジスタ
                        25 		***************
                        26 		.equ TCTL1,     REGBASE+0x600     |タイマ１コントロールレジスタ
                        27 		.equ TPRER1,    REGBASE+0x602     |タイマ１プリスケーラレジスタ
                        28 		.equ TCMP1,     REGBASE+0x604     |タイマ１コンペアレジスタ
                        29 		.equ TCN1,      REGBASE+0x608     |タイマ１カウンタレジスタ
                        30 		.equ TSTAT1,    REGBASE+0x60a     |タイマ１ステータスレジスタ
                        31 
                        32 		***************
                        33 		** UART1（送受信）関係のレジスタ
                        34 		***************
                        35 		.equ USTCNT1,   REGBASE+0x900     | UART1ステータス/コントロールレジスタ
                        36 		.equ UBAUD1,    REGBASE+0x902     | UART1ボーコントロールレジスタ
                        37 		.equ URX1,      REGBASE+0x904     | UART1受信レジスタ
                        38 		.equ UTX1,      REGBASE+0x906     | UART1送信レジスタ
                        39 
                        40 		***************
                        41 		** LED
                        42 		***************
                        43 		.equ LED7,      IOBASE+0x000002f  |ボード搭載のLED用レジスタ
                        44 		.equ LED6,      IOBASE+0x000002d  |使用法については付録A.4.3.1
                        45 		.equ LED5,      IOBASE+0x000002b
                        46 		.equ LED4,      IOBASE+0x0000029
                        47 		.equ LED3,      IOBASE+0x000003f
                        48 		.equ LED2,      IOBASE+0x000003d
                        49 		.equ LED1,      IOBASE+0x000003b
                        50 		.equ LED0,      IOBASE+0x0000039
                        51 
                        52 		***************************************************************
                        53 		** スタック領域の確保
                        54 		***************************************************************
                        55 		.section .bss
                        56 		.even
                        57 SYS_STK:
000800 0000 0000        58 		.ds.b   0x4000  |システムスタック領域
       0000 0000        58 
       0000 0000        58 
       0000 0000        58 
       0000 0000        58 
                        59 		.even
                        60 SYS_STK_TOP:            |システムスタック領域の最後尾
                        61 
                        62 		***************************************************************
                        63 		** 初期化
                        64 		** 内部デバイスレジスタには特定の値が設定されている．
                        65 		** その理由を知るには，付録Bにある各レジスタの仕様を参照すること．
                        66 		***************************************************************
                        67 		.section .text
                        68 		.even
                        69 boot:
                        70 		* スーパーバイザ&各種設定を行っている最中の割込禁止
000400 46FC 2700        71 		move.w #0x2700,%SR
000404 4FF9 0000        72 		lea.l  SYS_STK_TOP, %SP | Set SSP
       0000             72 
                        73 
                        74 		****************
                        75 		**割り込みコントローラの初期化
                        76 		****************
00040a 13FC 0040        77 		move.b #0x40, IVR       |ユーザ割り込みベクタ番号を| 0x40+levelに設定．
       00FF F300        77 
000412 23FC 00FF        78 		move.l #0x00ffffff,IMR  |全割り込みマスク /* STEP2.3 */
       FFFF 00FF        78 
       F304             78 
00041c 4EB9 0000        79 		jsr Init_Q
       0000             79 
                        80 
                        81 		****************
                        82 		** 送受信(UART1)関係の初期化(割り込みレベルは4に固定されている)
                        83 		****************
000422 33FC 0000        84 		move.w #0x0000, USTCNT1 |リセット
       00FF F900        84 
00042a 33FC E100        85 		move.w #0xe100, USTCNT1 |送受信可能,パリティなし, 1 stop, 8 bit,|送受割り込み禁
       00FF F900        85 
000432 33FC 0038        86 		move.w #0x0038, UBAUD1  |baud rate = 230400 bps
       00FF F902        86 
                        87 
                        88 		****************
                        89 		** タイマ関係の初期化(割り込みレベルは6に固定されている)
                        90 		*****************
00043a 33FC 0004        91 		move.w #0x0004, TCTL1   | restart,割り込み不可,|システムクロックの1/16を単位と
       00FF F600        91 
                        92 
                        93 		***************************************************************
                        94 		** STEP2の処理
                        95 		***************************************************************
                        96 		*lea.l uart1_interrupt, %a0
                        97 		*move.l %a0, 0x110 /* STEP2.1 level 4, (64+4)*4 割り込み処理ルーチンの開始アドレ
                        98 
                        99 
                       100 
                       101 
000442 21FC 0000       102 		move.l #uart1_interrupt, 0x110
       0000 0110       102 
00044a 33FC E108       103 		move.w #0xe108, USTCNT1 |受信割り込み許可、送信割り込み無効 /* STEP2.2 */
       00FF F900       103 
000452 23FC 00FF       104 		move.l #0x00ff3ffb,IMR  |受信割り込みマスク /* STEP2.3 */
       3FFB 00FF       104 
       F304            104 
00045c 46FC 2000       105 		move.w #0x2000, %SR    /* STEP2.4 割り込み許可．(スーパーバイザモードの場合) 
                       106 
000460 6000 0002       107 		bra MAIN
                       108 
                       109 		***************************************************************
                       110 		** 現段階での初期化ルーチンの正常動作を確認するため，最後に’a’を
                       111 		** 送信レジスタUTX1に書き込む．'a'が出力されれば，OK.
                       112 		***************************************************************
                       113 		.section .text
                       114 		.even
                       115 
                       116 
                       117 
                       118 
                       119 	
                       120 MAIN:
                       121 		*move.w #0x0800+'a', UTX1 | 0x0800を足す理由については，|付録参照
000464 4EBA 0006       122 		jsr TEST_READY
                       123 		
                       124 LOOP:
000468 6000 FFFE       125 		bra LOOP
                       126 
                       127 *******************************************************
                       128 **                  INTERPUT テスト (STEP4)
                       129 *******************************************************
                       130 TEST_READY:
                       131 		*movem.l %d1-%d5, -(%sp)
                       132 	
00046c 383C 0010       133 		move.w #16, %d4
000470 3A3C 0010       134 		move.w #16, %d5
000474 123C 0061       135 		move.b #0x61, %d1
000478 6000 0008       136 		bra TEST_LOOP
                       137 
                       138 TEST_LOOP2:
                       139         *addq #1, %d1 /*変更前*/
00047c 5201            140 		addq.b #1, %d1  /*変更後*/
                       141         
00047e 383C 0010       142 		move.w #16, %d4
                       143 
                       144 TEST_LOOP:
                       145 		*moveq #0, %d0 /* 変更前 */
000482 7000            146         move.l #0, %d0 /* 変更後 */
000484 4EB9 0000       147 		jsr INQ
       0000            147 
00048a 5344            148 		subq.w #1, %d4
00048c 6600 FFF4       149 		bne TEST_LOOP
000490 5345            150 		subq.w #1, %d5
000492 6700 0006       151 		beq TEST_END
000496 6000 FFE4       152 		bra TEST_LOOP2
                       153 
                       154 TEST_END:
                       155 		*movem.l (%sp)+, %d1-%d5
00049a 4E75            156 		rts
                       157 
                       158 ******************************************
                       159 **          UART1  割り込み処理
                       160 ******************************************
                       161 
                       162 uart1_interrupt:
00049c 13FC 0033       163 		move.b #'3', LED5
       00D0 002B       163 
0004a4 48E7 8000       164 		movem.l %d0, -(%sp)
                       165 
                       166 		*move.b #'a', %d0 /* URX1の下位8ビットのデータを転送 */
                       167 		*addi.w #0x0800, %d0 /* 即値をレジスタd0に加算 */
                       168 		*move.w %d0, UTX1 /* 16ビットのデータをUTX1に転送 */
                       169 
                       170 
0004a8 3039 00FF       171 		move.w UTX1, %d0	/*step4:UTX1のコピー*/
       F906            171 
                       172 		
0004ae 7200            173 		move.l #0, %d1	/*chの選択*/
                       174 
0004b0 0C40 8000       175 		cmp #0x8000,%d0
0004b4 6400 0008       176 		bcc INTERPUT
                       177 
0004b8 4CDF 0001       178 		movem.l (%sp)+, %d0
                       179 		
0004bc 4E73            180 		rte
                       181 
                       182 **********************************************
                       183 ** INTERPUT  (データサイズを可能なかぎりlongにした)
                       184 **********************************************
                       185 
                       186 INTERPUT:
0004be 48E7 E000       187 		movem.l %d0-%d2, -(%sp)
                       188 
                       189         /*step4.1:走行レベル7*/
0004c2 46FC 2700       190 		move.w #0x2700, %SR	
                       191 
                       192         /*step4.2:ch!=0で分岐*/
0004c6 0C81 0000       193 		cmp.l #0x0, %d1		
       0000            193 
0004cc 6600 0020       194 		bne INTERPUT_END
                       195 
                       196         /* QUEUEの選択 */
0004d0 7001            197 		move.l #1, %d0
                       198 
                       199         /*step4.3:OUTQの実行*/
0004d2 4EB9 0000       200 		jsr OUTQ		
       0000            200 
                       201 
                       202         /*step4.4:戻り値が0で分岐*/
0004d8 0C80 0000       203 		cmp.l #0, %d0		
       0000            203 
0004de 6700 0014       204 		beq INTERPUT_MASK
                       205 
                       206         /*=========データの送信=======*/ 
                       207         /* 文字化けしたらここに注意 */
0004e2 1401            208 		move.b %d1, %d2
                       209         /*step4.5:ヘッダ付与*/
0004e4 0642 0800       210 		addi.w #0x0800, %d2
0004e8 33C2 00FF       211 		move.w %d2, UTX1	
       F906            211 
                       212         /*=========================*/
                       213 
                       214 
                       215 INTERPUT_END:
0004ee 4CDF 0007       216 		movem.l (%sp)+, %d0-%d2
                       217 		*movem.l (%sp)+, %d0
                       218 
0004f2 4E73            219 		rte
                       220 
                       221 INTERPUT_MASK:
0004f4 33FC E10C       222 		move.w #0xe10c, USTCNT1	/*step4.4:送信割り込みのマスク*/
       00FF F900       222 
                       223 		/* ↑ 何故かコメントアウトされていたので、修正 */
                       224 
0004fc 6000 FFF0       225 		bra INTERPUT_END
                       226 
                       227 /* キュー領域の前後での書き込みが発生していないことを確認すること*/
                       228 *******************************************************
                       229 ** 						QUEUE (TA)
                       230 *******************************************************
                       231 
                       232 
                       233 .section .data
                       234 .equ TOP, 0
                       235 .equ BOTTOM, 4
                       236 .equ IN, 8
                       237 .equ OUT, 12
                       238 .equ S, 16
                       239 .equ DATA_TOP, 18
                       240 .equ DATA_LEN, 256
                       241 .equ QUEUE_SIZE, DATA_TOP + DATA_LEN /* 18 + 256 = 274 */
                       242 
000500 0000 0000       243 QUEUE_TOP: ds.b QUEUE_SIZE * 2
       0000 0000       243 
       0000 0000       243 
       0000 0000       243 
       0000 0000       243 
                       244 
                       245 /* 初期化 */
                       246 ********************
                       247 * 初期化
                       248 ********************
                       249 
                       250 Init_Q:
000724 48E7 C0E0       251     movem.l %d0-%d1/%a0-%a2, -(%sp) /* 使用レジスタの退避 */
                       252 
000728 7000            253     move.l #0, %d0 /* キュー番号 = 0 */
                       254 
                       255 Init_Q_sub:
00072a 41FA FDD4       256     lea.l QUEUE_TOP, %a0 /* キューの先頭アドレス */
00072e 2200            257     move.l %d0, %d1
000730 C2F8 0112       258     mulu.w QUEUE_SIZE, %d1 /* キューnの相対先頭アドレス = n * (キューサイズ) */
000734 D1C1            259     add.l %d1, %a0 /* a0 = キューnの先頭アドレス */
000736 43E8 0012       260     lea.l DATA_TOP(%a0), %a1 /* a1 = キューnのデータ領域先頭アドレス = DATA_TOP + a0
00073a 2089            261     move.l %a1, TOP(%a0) /* キューnのTOPのアドレス = a0 + TOP であるのでそこにa1
00073c 2149 0008       262     move.l %a1, IN(%a0) /* キューnのINのアドレスにa1を格納 */
000740 2149 000C       263     move.l %a1, OUT(%a0) /* キューnのOUTのアドレスにa1を格納 */
000744 43E8 0004       264     lea.l BOTTOM(%a0), %a1 /* a1 = キューnのBOTTOMのアドレス */
000748 43E8 0111       265     lea.l QUEUE_SIZE-1(%a0), %a1 /* a1 == BOTTOM = キューnの終端アドレス */
00074c 317C 0000       266     move.w #0, S(%a0) /* データ数 = 0 */
       0010            266 
000752 5280            267     addq.l #1, %d0 /* キュー番号++ */
000754 0C80 0000       268     cmpi.l #2, %d0 /* キューの個数分(2)ループ */
       0002            268 
00075a 6600 FFCE       269     bne Init_Q_sub
                       270 
00075e 4CDF 0703       271     movem.l (%sp)+, %d0-%d1/%a0-%a2 /* 使用レジスタの復帰 */
000762 4E75            272     rts
                       273 
                       274 
                       275 *****************
                       276 ** INQ
                       277 *****************
                       278 
                       279 **************************************
                       280 **入力
                       281 **  d0:キューの選択 [long]
                       282 **  d1:書き込むデータ [long]
                       283 **出力
                       284 **  d0:成功(1)or失敗(0) [long]
                       285 **************************************
                       286 INQ:
                       287 
                       288     /* 現走行レベルの退避 */
000764 40E7            289     move.w %SR, -(%sp)
                       290 
                       291     /* 割り込み禁止 */
000766 46FC 2700       292     move.w #0x2700, %SR
                       293 
00076a 48E7 00C0       294     movem.l %a0-%a1, -(%sp)
00076e 41FA FD90       295     lea.l QUEUE_TOP, %a0 /* a0 = キュー0の先頭アドレス */
000772 C0F8 0112       296     mulu.w QUEUE_SIZE, %d0 /* キューnの相対先頭アドレス = n * (キューサイズ) */
000776 D1C0            297     add.l %d0, %a0 /* a0 = キューnの先頭アドレス */
                       298 
000778 0C68 0100       299     cmpi.w #256, S(%a0)
       0010            299 
00077e 6600 0008       300     bne INQ_1
                       301 
                       302     /* S == 256のときd0 = 0(失敗) としてENDへ */
000782 7000            303     move.l #0, %d0
000784 6000 0024       304     bra INQ_END
                       305 
                       306 INQ_1:
000788 2268 0008       307     movea.l IN(%a0), %a1 /* a1 = in */
00078c 1281            308     move.b %d1, (%a1) /* q[in] = d1 */ 
                       309 
00078e B3E8 0004       310     cmpa.l BOTTOM(%a0), %a1 /* in == bottom かを判定 */
000792 6600 000A       311     bne INQ_ELSE
                       312 
                       313     /* in == bottom のとき*/
000796 2150 0008       314     move.l TOP(%a0), IN(%a0) /* in = top */
00079a 6000 0008       315     bra INQ_2
                       316 
                       317 /* in != bottom のとき*/
                       318 INQ_ELSE:
00079e 5289            319     addq.l #1, %a1 /* a1++ */
0007a0 2149 0008       320     move.l %a1, IN(%a0) /* in = a1 */
                       321 
                       322 /* s++, d0 = 1(成功) としてENDへ */
                       323 INQ_2:
0007a4 5268 0010       324     addq.w #1, S(%a0)
0007a8 7001            325     move.l #1, %d0
                       326 
                       327 /* 使用レジスタの復帰 */
                       328 INQ_END:
0007aa 4CDF 0300       329     movem.l (%sp)+, %a0-%a1 
0007ae 46DF            330     move.w (%sp)+, %SR
0007b0 4E75            331     rts
                       332 
                       333 
                       334 *****************
                       335 * OUTQ
                       336 *****************
                       337 
                       338 **********************************************
                       339 **入力
                       340 **  d0:キューの選択  [long]
                       341 
                       342 **出力
                       343 **  d0:成功(1)or失敗(0) [long]
                       344 **  d1:取り組んだデータ [byte]
                       345 **********************************************
                       346 OUTQ:
                       347     /* 現走行レベルの退避 */
0007b2 40E7            348     move.w %SR, -(%sp)
                       349 
                       350     /* 割り込み禁止 */
0007b4 46FC 2700       351     move.w #0x2700, %SR
                       352 
0007b8 48E7 00C0       353     movem.l %a0-%a1, -(%sp)
0007bc 41FA FD42       354     lea.l QUEUE_TOP, %a0 /* a0 = キュー0の先頭アドレス */
0007c0 C0F8 0112       355     mulu.w QUEUE_SIZE, %d0 /* キューnの相対先頭アドレス = n * (キューサイズ) */
0007c4 D1C0            356     add.l %d0, %a0 /* a0 = キューnの先頭アドレス */
                       357 
0007c6 0C68 0000       358     cmpi.w #0, S(%a0)
       0010            358 
0007cc 6600 0008       359     bne OUTQ_1
                       360 
                       361     /* S == 0のときd0 = 0(失敗) としてENDへ */
0007d0 7000            362     move.l #0, %d0
0007d2 6000 0024       363     bra OUTQ_END
                       364 
                       365 OUTQ_1:
0007d6 2268 000C       366     movea.l OUT(%a0), %a1 /* a1 = out */
0007da 1211            367     move.b (%a1), %d1 /* d1 = q[out] */
                       368 
0007dc B3E8 0004       369     cmpa.l BOTTOM(%a0), %a1 /* out == bottom かを判定 */
0007e0 6600 000A       370     bne OUTQ_ELSE
                       371 
                       372     /* out == bottom のとき*/
0007e4 2150 000C       373     move.l TOP(%a0), OUT(%a0) /* out = top */
0007e8 6000 0008       374     bra OUTQ_2
                       375 
                       376 /* out != bottom のとき*/
                       377 OUTQ_ELSE:
0007ec 5289            378     addq.l #1, %a1 /* a1++ */
0007ee 2149 000C       379     move.l %a1, OUT(%a0) /* out = a1 */
                       380 
                       381 /* s--, d0 = 1(成功) としてENDへ */
                       382 OUTQ_2:
0007f2 5368 0010       383     subq.w #1, S(%a0)
0007f6 7001            384     move.l #1, %d0
                       385 
                       386 /* 使用レジスタの復帰 */
                       387 OUTQ_END:
0007f8 4CDF 0300       388     movem.l (%sp)+, %a0-%a1 
0007fc 46DF            389     move.w (%sp)+, %SR
0007fe 4E75            390     rts
                       391 
